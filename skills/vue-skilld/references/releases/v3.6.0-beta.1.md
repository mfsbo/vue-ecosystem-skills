---
tag: v3.6.0-beta.1
version: 3.6.0-beta.1
published: 2025-12-23
---

# v3.6.0-beta.1

Vue 3.6 is now entering beta phase as we have completed the intended feature set for Vapor Mode as outlined in the roadmap! Vapor Mode now has feature parity with all stable features in Virtual DOM mode. Suspense is not supported in Vapor-only mode, but you can render Vapor components inside a VDOM Suspense.

3.6 also includes a major refactor of `@vue/reactivity` based on alien-signals, which significantly improves the reactivity system's performance and memory usage.

For more details about Vapor Mode, see [About Vapor Mode](#about-vapor-mode) section at the end of this release note.

### Features

* **runtime-vapor:** support render block in createDynamicComponent (#14213) (ddc1bae)


### Performance Improvements

* **runtime-vapor:** implement dynamic props/slots source caching (#14208) (1428c06)

### Bug Fixes

* **compiler-vapor:** camelize kebab-case component event handlers (#14211) (b205408)
* **compiler-vapor:** merge component v-model onUpdate handlers (#14229) (e6bff23)
* **compiler-vapor:** wrap handler values in functions for dynamic v-on (#14218) (1e3e1ef)
* **hmr:** suppress `provide()` warning during HMR updates for mounted instances (#14195) (d823d6a)
* **keep-alive:** preserve fragment's scope only if it include a component that should be cached (26b0b37)
* **runtime-core:** remove constructor props for defineComponent (#14223) (ad0a237)
* **runtime-vapor:** implement v-once caching for props and attrs (#14207) (be2b79d)
* **runtime-vapor:** optimize prop handling in VaporTransitionGroup using Proxy (0ceebeb)
* **transition:** move kept-alive node before v-show transition leave finishes (e393552)
* **transition:** optimize prop handling in VaporTransition using Proxy (b092624)
* **transition:** prevent unmounted block from being inserted after transition leave (f9a9fad)

### About Vapor Mode

Vapor Mode is a new compilation mode for Vue Single-File Components (SFC) with the goal of reducing baseline bundle size and improved performance. It is 100% opt-in, and supports a subset of existing Vue APIs with mostly identical behavior.

Vapor Mode has demonstrated the same level of performance with Solid and Svelte 5 in 3rd party benchmarks.

#### General Stability Notes

Vapor Mode is feature-complete in Vue 3.6 beta, but is still considered unstable. For now, we recommend using it for the following cases:

- Partial usage in existing apps, e.g. implementing a perf-sensitive sub page in Vapor Mode.
- Build small new apps entirely in Vapor Mode.

#### Opting in to Vapor Mode

Vapor Mode only works for Single File Components using `<script setup>`. To opt-in, add the `vapor` attribute to `<script setup>`:

```vue
<script setup vapor>
// ...
</script>
```

Vapor Mode components are usable in two scenarios:

1. Inside a Vapor app instance create via `createVaporApp`. Apps created this way avoids pulling in the Virtual DOM runtime code and allows bundle baseline size to be drastically reduced.

2. To use Vapor components in a VDOM app instance created via `createApp`, the `vaporInteropPlugin` must be installed:

   ```js
   import { createApp, vaporInteropPlugin } from 'vue'
   import App from './App.vue'

   createApp(App)
     .use(vaporInteropPlugin) // enable vapor interop
     .mount('#app')
   ```

   A Vapor app instance can also install `vaporInteropPlugin` to allow vdom components to be used inside, but it will pull in the vdom runtime and offset the benefits of a smaller bundle.

#### VDOM Interop Limitations

When the interop plugin is installed, Vapor and non-Vapor components can be nested inside each other. This currently covers standard props, events, and slots usage, but does not yet account for all possible edge cases. For example, there will most likely still be rough edges when using a VDOM-based component library in Vapor Mode.

A know issue is that vapor slots cannot be rendered with `slots.default()` inside a VDOM component. `renderSlot` must be used instead. [Example]

This is expected to improve over time, but in general, we recommend having distinct "regions" in your app where it's one mode or another, and avoid mixed nesting as much as possible.

In the future, we may provide support tooling to enforce Vapor usage boundaries in codebases.

#### Feature Compatibility

By design, Vapor Mode supports a **subset** of existing Vue features. For the supported subset, we aim to deliver the exact same behavior per API specifications. At the same time, this means there are some features that are explicitly not supported in Vapor Mode:

- Options API
- `app.config.globalProperties`
- `getCurrentInstance()` returns `null` in Vapor components
- `@vue:xxx` per-element lifecycle events

Custom directives in Vapor also have a different interface:

```ts
type VaporDirective = (
  node: Element | VaporComponentInstance,
  value?: () => any,
  argument?: string,
  modifiers?: DirectiveModifiers,
) => (() => void) | void
```

`value` is a reactive getter that returns the binding value. The user can set up reactive effects using `watchEffect` (auto released when component unmounts), and can optionally return a cleanup function. Example:

```ts
const MyDirective = (el, source) => {
  watchEffect(() => {
    el.textContent = source()
  })
  return () => console.log('cleanup')
}
```

#### Behavior Consistency

Vapor Mode attempts to match VDOM Mode behavior as much as possible, but there could still be minor behavior inconsistencies in edge cases due to how fundamentally different the two rendering modes are. In general, we do not consider a minor inconsistency to be breaking change unless the behavior has previously been documented.

For stable releases, please refer to CHANGELOG.md for details.
For pre-releases, please refer to CHANGELOG.md of the `minor` branch.