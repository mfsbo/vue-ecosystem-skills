---
title: VeeValidate
description: Build forms in Vue using VeeValidate and Zod.
links:
  doc: https://vee-validate.logaretm.com/v4
---

In this guide, we will take a look at building forms with VeeValidate. We'll cover building forms with the `<Field />` component, adding schema validation using Zod, error handling, accessibility, and more.

## Demo

We are going to build the following form. It has a simple text input and a textarea. On submit, we'll validate the form data and display any errors.

::callout
---
icon: true
---
**Note:** For the purpose of this demo, we have intentionally disabled browser validation to show how schema validation and form errors work in VeeValidate. It is recommended to add basic browser validation in your production code.
::

::component-preview
---
name: VeeValidateDemo
class: sm:[&_.preview]:h-[700px] sm:[&_pre]:!h-[700px]
chromeLessOnMobile: true
---
::

## Approach

This form leverages VeeValidate for performant, flexible form handling. We'll build our form using the `<Field />` component, which gives you **complete flexibility over the markup and styling**.

- Uses VeeValidate's `useForm` composable for form state management.
- VeeValidate's `<Field />` component with scoped slots for controlled inputs with validation.
- shadcn-vue `<Field />` components for building accessible forms.
- Client-side validation using Zod with `toTypedSchema`.

## Anatomy

Here's a basic example of a form using VeeValidate's `<Field />` component with scoped slots and shadcn-vue `<Field />` components.

```vue showLineNumbers {2-19}
<template>
  <VeeField v-slot="{ field, errors }" name="title">
    <Field :data-invalid="!!errors.length">
      <FieldLabel for="title">
        Bug Title
      </FieldLabel>
      <Input
        id="title"
        v-bind="field"
        placeholder="Login button not working on mobile"
        autocomplete="off"
        :aria-invalid="!!errors.length"
      />
      <FieldDescription>
        Provide a concise title for your bug report.
      </FieldDescription>
      <FieldError v-if="errors.length" :errors="errors" />
    </Field>
  </VeeField>
</template>
```

## Form

### Create a form schema

We'll start by defining the shape of our form using a Zod schema

::callout
---
icon: true
---
**Note:** This example uses `zod v3` for schema validation, but you can replace it with any other Standard Schema validation library supported by VeeValidate.
::

```vue showLineNumbers title="Form.vue"
<script setup lang="ts">
import * as z from 'zod'

const formSchema = z.object({
  title: z
    .string()
    .min(5, 'Bug title must be at least 5 characters.')
    .max(32, 'Bug title must be at most 32 characters.'),
  description: z
    .string()
    .min(20, 'Description must be at least 20 characters.')
    .max(100, 'Description must be at most 100 characters.'),
})
</script>
```

### Setup the form

Next, we'll use the `useForm` composable from VeeValidate to create our form instance. We'll also add the Zod schema for validation.

```vue showLineNumbers title="Form.vue" {17-23}
<script setup lang="ts">
import { toTypedSchema } from '@vee-validate/zod'
import { useForm, Field as VeeField } from 'vee-validate'
import * as z from 'zod'

const formSchema = z.object({
  title: z
    .string()
    .min(5, 'Bug title must be at least 5 characters.')
    .max(32, 'Bug title must be at most 32 characters.'),
  description: z
    .string()
    .min(20, 'Description must be at least 20 characters.')
    .max(100, 'Description must be at most 100 characters.'),
})

const { handleSubmit } = useForm({
  validationSchema: toTypedSchema(formSchema),
  initialValues: {
    title: '',
    description: '',
  },
})

const onSubmit = handleSubmit((values) => {
  // Do something with the form values.
  console.log(values)
})
</script>

<template>
  <form @submit="onSubmit">
    
  </form>
</template>
```

### Build the form

We can now build the form using VeeValidate's `<Field />` component with scoped slots and shadcn-vue `<Field />` components.


::component-source{name="VeeValidateDemo" title="Form.vue"}
::

### Done

That's it. You now have a fully accessible form with client-side validation.

When you submit the form, the `onSubmit` function will be called with the validated form data. If the form data is invalid, VeeValidate will display the errors next to each field.

## Validation

### Client-side Validation

VeeValidate validates your form data using the Zod schema. Define a schema and pass it to the `validationSchema` option of the `useForm` composable.

```vue showLineNumbers title="ExampleForm.vue" {6-9,12}
<script setup lang="ts">
import { toTypedSchema } from '@vee-validate/zod'
import { useForm, Field as VeeField } from 'vee-validate'
import * as z from 'zod'

const formSchema = z.object({
  title: z.string(),
  description: z.string().optional(),
})

const { handleSubmit } = useForm({
  validationSchema: toTypedSchema(formSchema),
  initialValues: {
    title: '',
    description: '',
  },
})
</script>
```

### Validation Modes

VeeValidate supports different validation strategies through the `Field` component props.

```vue showLineNumbers title="Form.vue" {4}
<VeeField
  v-slot="{ field, errors }"
  name="title"
  :validate-on-input="true"
>
  
</VeeField>
```

| Prop                    | Description                                              |
| ----------------------- | -------------------------------------------------------- |
| `validateOnInput`       | Validation triggers on input event.                     |
| `validateOnChange`      | Validation triggers on change event.                    |
| `validateOnBlur`        | Validation triggers on blur event.                      |
| `validateOnMount`       | Validation triggers when component is mounted.          |

## Displaying Errors

Display errors next to the field using `<FieldError />`. For styling and accessibility:

- Add the `:data-invalid` prop to the shadcn-vue `<Field />` component.
- Add the `:aria-invalid` prop to the form control such as `<Input />`, `<SelectTrigger />`, `<Checkbox />`, etc.

```vue showLineNumbers title="Form.vue" {2,9,11}
<template>
  <VeeField v-slot="{ field, errors }" name="email">
    <Field :data-invalid="!!errors.length">
      <FieldLabel for="email">
        Email
      </FieldLabel>
      <Input
        id="email"
        v-bind="field"
        type="email"
        :aria-invalid="!!errors.length"
      />
      <FieldError v-if="errors.length" :errors="errors" />
    </Field>
  </VeeField>
</template>
```

## Working with Different Field Types

### Input

- For input fields, use `v-bind="field"` to bind VeeValidate's field object to the input.
- To show errors, add the `:aria-invalid` prop to the `<Input />` component and the `:data-invalid` prop to the shadcn-vue `<Field />` component.

::component-preview
---
name: VeeValidateInputDemo
class: sm:[&_.preview]:h-[700px] sm:[&_pre]:!h-[700px]
chromeLessOnMobile: true
---
::

For simple text inputs, use VeeValidate's `Field` component with scoped slots.

```vue showLineNumbers title="Form.vue" {3,9,11}
<template>
  <VeeField v-slot="{ field, errors }" name="name">
    <Field :data-invalid="!!errors.length">
      <FieldLabel for="name">
        Name
      </FieldLabel>
      <Input
        id="name"
        v-bind="field"
        placeholder="Enter your name"
        :aria-invalid="!!errors.length"
      />
      <FieldError v-if="errors.length" :errors="errors" />
    </Field>
  </VeeField>
</template>
```

### Textarea

- For textarea fields, use `v-bind="field"` to bind VeeValidate's field object to the textarea.
- To show errors, add the `:aria-invalid` prop to the `<Textarea />` component and the `:data-invalid` prop to the shadcn-vue `<Field />` component.

::component-preview
---
name: VeeValidateTextareaDemo
class: sm:[&_.preview]:h-[700px] sm:[&_pre]:!h-[700px]
chromeLessOnMobile: true
---
::

For textarea fields, use VeeValidate's `Field` component with scoped slots.

```vue showLineNumbers title="Form.vue" {3,12,16}
<template>
  <VeeField v-slot="{ field, errors }" name="about">
    <Field :data-invalid="!!errors.length">
      <FieldLabel for="about">
        More about you
      </FieldLabel>
      <Textarea
        id="about"
        v-bind="field"
        placeholder="I'm a software engineer..."
        class="min-h-[120px]"
        :aria-invalid="!!errors.length"
      />
      <FieldDescription>
        Tell us more about yourself. This will be used to help us personalize your experience.
      </FieldDescription>
      <FieldError v-if="errors.length" :errors="errors" />
    </Field>
  </VeeField>
</template>
```

### Select

- For select components, use `field.value` and `@update:model-value="field.onChange"` for proper binding.
- To show errors, add the `:aria-invalid` prop to the `<SelectTrigger />` component and the `:data-invalid` prop to the shadcn-vue `<Field />` component.

::component-preview
---
name: VeeValidateSelectDemo
class: sm:[&_.preview]:h-[500px] sm:[&_pre]:!h-[500px]
chromeLessOnMobile: true
---
::

```vue showLineNumbers title="Form.vue" {3,9,19}
<template>
  <VeeField v-slot="{ field, errors }" name="language">
    <Field orientation="responsive" :data-invalid="!!errors.length">
      <FieldContent>
        <FieldLabel for="language">
          Spoken Language
        </FieldLabel>
        <FieldDescription>For best results, select the language you speak.</FieldDescription>
        <FieldError v-if="errors.length" :errors="errors" />
      </FieldContent>
      <Select
        :model-value="field.value"
        @update:model-value="field.onChange"
        @blur="field.onBlur"
      >
        <SelectTrigger
          id="language"
          class="min-w-[120px]"
          :aria-invalid="!!errors.length"
        >
          <SelectValue placeholder="Select" />
        </SelectTrigger>
        <SelectContent position="item-aligned">
          <SelectItem value="auto">
            Auto
          </SelectItem>
          <SelectItem value="en">
            English
          </SelectItem>
        </SelectContent>
      </Select>
    </Field>
  </VeeField>
</template>
```

### Checkbox

- For checkbox arrays, use VeeValidate's `Field` component with a custom handler to manage array state.
- To show errors, add the `:aria-invalid` prop to the `<Checkbox />` component and the `:data-invalid` prop to the shadcn-vue `<Field />` component.
- Remember to add `data-slot="checkbox-group"` to the `<FieldGroup />` component for proper styling and spacing.

::component-preview
---
name: VeeValidateCheckboxDemo
class: sm:[&_.preview]:h-[700px] sm:[&_pre]:!h-[700px]
chromeLessOnMobile: true
---
::

```vue showLineNumbers title="Form.vue" {13,16-25,32}
<template>
  <VeeField v-slot="{ field, errors }" name="tasks">
    <FieldSet>
      <FieldLegend variant="label">
        Tasks
      </FieldLegend>
      <FieldDescription>Get notified when tasks you've created have updates.</FieldDescription>
      <FieldGroup data-slot="checkbox-group">
        <Field
          v-for="task in tasks"
          :key="task.id"
          orientation="horizontal"
          :data-invalid="!!errors.length"
        >
          <Checkbox
            :id="`task-${task.id}`"
            :model-value="field.value?.includes(task.id) ?? false"
            :aria-invalid="!!errors.length"
            @update:model-value="(checked | 'indeterminate') => {
              const currentTasks = field.value || []
              const newValue = checked
                ? [...currentTasks, task.id]
                : currentTasks.filter(id => id !== task.id)
              field.onChange(newValue)
            }"
          />
          <FieldLabel :for="`task-${task.id}`" class="font-normal">
            {{ task.label }}
          </FieldLabel>
        </Field>
      </FieldGroup>
      <FieldError v-if="errors.length" :errors="errors" />
    </FieldSet>
  </VeeField>
</template>
```

### Radio Group

- For radio groups, use `field.value` and `@update:model-value="field.onChange"` for proper binding.
- To show errors, add the `:aria-invalid` prop to the `<RadioGroupItem />` component and the `:data-invalid` prop to the shadcn-vue `<Field />` component.

::component-preview
---
name: VeeValidateRadioGroupDemo
class: sm:[&_.preview]:h-[700px] sm:[&_pre]:!h-[700px]
chromeLessOnMobile: true
---
::

```vue showLineNumbers title="Form.vue" {9-10,13,21,26}
<template>
  <VeeField v-slot="{ field, errors }" name="plan">
    <FieldSet>
      <FieldLegend>Plan</FieldLegend>
      <FieldDescription>
        You can upgrade or downgrade your plan at any time.
      </FieldDescription>
      <RadioGroup
        :model-value="field.value"
        @update:model-value="field.onChange"
      >
        <FieldLabel v-for="planOption in plans" :key="planOption.id" :for="`plan-${planOption.id}`">
          <Field orientation="horizontal" :data-invalid="!!errors.length">
            <FieldContent>
              <FieldTitle>{{ planOption.title }}</FieldTitle>
              <FieldDescription>{{ planOption.description }}</FieldDescription>
            </FieldContent>
            <RadioGroupItem
              :id="`plan-${planOption.id}`"
              :value="planOption.id"
              :aria-invalid="!!errors.length"
            />
          </Field>
        </FieldLabel>
      </RadioGroup>
      <FieldError v-if="errors.length" :errors="errors" />
    </FieldSet>
  </VeeField>
</template>
```

### Switch

- For switches, use `:model-value="field.value"` and `@update:model-value="field.onChange"` for proper binding.
- To show errors, add the `:aria-invalid` prop to the `<Switch />` component and the `:data-invalid` prop to the shadcn-vue `<Field />` component.

::component-preview
---
name: VeeValidateSwitchDemo
class: sm:[&_.preview]:h-[500px] sm:[&_pre]:!h-[500px]
chromeLessOnMobile: true
---
::

```vue showLineNumbers title="Form.vue" {3,11,15-17}
<template>
  <VeeField v-slot="{ field, errors }" name="twoFactor">
    <Field orientation="horizontal" :data-invalid="!!errors.length">
      <FieldContent>
        <FieldLabel for="two-factor">
          Multi-factor authentication
        </FieldLabel>
        <FieldDescription>
          Enable multi-factor authentication to secure your account.
        </FieldDescription>
        <FieldError v-if="errors.length" :errors="errors" />
      </FieldContent>
      <Switch
        id="two-factor"
        :model-value="field.value"
        :aria-invalid="!!errors.length"
        @update:model-value="field.onChange"
      />
    </Field>
  </VeeField>
</template>
```

### Complex Forms

Here is an example of a more complex form with multiple fields and validation.

::component-preview
---
name: VeeValidateComplexDemo
class: sm:[&_.preview]:h-[1300px] sm:[&_pre]:!h-[1300px]
chromeLessOnMobile: true
---
::

## Resetting the Form

Use the `resetForm` function returned by `useForm` to reset the form to its initial values.

```vue showLineNumbers
<script setup lang="ts">
const { handleSubmit, resetForm } = useForm({
  validationSchema: formSchema,
  // ...
})
</script>

<template>
  <Button type="button" variant="outline" @click="resetForm">
    Reset
  </Button>
</template>
```

## Array Fields

VeeValidate provides a `FieldArray` component for managing dynamic array fields. This is useful when you need to add or remove fields dynamically.

::component-preview
---
name: VeeValidateArrayDemo
class: sm:[&_.preview]:h-[700px] sm:[&_pre]:!h-[700px]
chromeLessOnMobile: true
---
::

### Using FieldArray

Use the `FieldArray` component to manage array fields. It provides `fields`, `push`, and `remove` methods through its slot props.

```vue showLineNumbers title="Form.vue" {6-8}
<script setup lang="ts">
import { FieldArray as VeeFieldArray } from 'vee-validate'
</script>

<template>
  <VeeFieldArray v-slot="{ fields, push, remove }" name="emails">
  
  </VeeFieldArray>
</template>
```

### Array Field Structure

Wrap your array fields in a `<FieldSet />` with a `<FieldLegend />` and `<FieldDescription />`.

```vue showLineNumbers title="Form.vue"
<template>
  <FieldSet class="gap-4">
    <FieldLegend variant="label">
      Email Addresses
    </FieldLegend>
    <FieldDescription>
      Add up to 5 email addresses where we can contact you.
    </FieldDescription>
    <FieldGroup class="gap-4">
      
    </FieldGroup>
  </FieldSet>
</template>
```

### Field Pattern for Array Items

Map over the `fields` array and create fields for each item. **Make sure to use `field.key` as the key**.

```vue showLineNumbers title="Form.vue"
<template>
  <VeeFieldArray v-slot="{ fields, push, remove }" name="emails">
    <VeeField
      v-for="(field, index) in fields"
      :key="field.key"
      v-slot="{ field: controllerField, errors }"
      :name="`emails[${index}].address`"
    >
      <Field orientation="horizontal" :data-invalid="!!errors.length">
        <FieldContent class="flex-1">
          <InputGroup>
            <InputGroupInput
              :id="`email-${index}`"
              v-bind="controllerField"
              type="email"
              placeholder="name@example.com"
              autocomplete="email"
              :aria-invalid="!!errors.length"
            />
            
          </InputGroup>
          <FieldError v-if="errors.length" :errors="errors" />
        </FieldContent>
      </Field>
    </VeeField>
  </VeeFieldArray>
</template>
```

### Adding Items

Use the `push` method to add new items to the array.

```vue showLineNumbers title="Form.vue"
<template>
  <Button
    type="button"
    variant="outline"
    size="sm"
    :disabled="fields.length >= 5"
    @click="push({ address: '' })"
  >
    Add Email Address
  </Button>
</template>
```

### Removing Items

Use the `remove` method to remove items from the array. Add the remove button conditionally.

```vue showLineNumbers title="Form.vue"
<template>
  <InputGroupAddon v-if="fields.length > 1" align="inline-end">
    <InputGroupButton
      type="button"
      variant="ghost"
      size="icon-xs"
      :aria-label="`Remove email ${index + 1}`"
      @click="remove(index)"
    >
      <XIcon />
    </InputGroupButton>
  </InputGroupAddon>
</template>
```

### Array Validation

Use Zod's `array` method to validate array fields.

```ts showLineNumbers title="Form.vue"
const formSchema = z.object({
  emails: z
    .array(
      z.object({
        address: z.string().email('Enter a valid email address.'),
      }),
    )
    .min(1, 'Add at least one email address.')
    .max(5, 'You can add up to 5 email addresses.'),
})
```
